@namespace barberchainAPI.Components.Pages
@using MudBlazor;
@using System.Collections;
@using barberchainAPI.Data
@using barberchainAPI.Functional
@using System.Security.Claims
@inject CartService CartService
@inject IJSRuntime JS
@inject BarberchainDbContext Context
@inject NavigationManager Navigation
@inject ISnackbar Snackbar

<style>
    .timeline-wrapper {
        overflow-x: auto;
        width: 100%;
    }

    .hour-markers,
    .availability-line {
        display: flex;
    }

    .hour-marker {
        flex: 0 0 auto; /* prevent shrinking */
        width: 100px; /* 4 slots per hour */
        text-align: left;
        font-size: 12px;
    }

    .time-block {
        flex: 0 0 auto; /* prevent shrinking */
        width: 25px;
        height: 25px;
        border-radius: 5px;
        border: 1px solid darkgrey;
    }

        .time-block.available {
            background-color: white;
        }

        .time-block.unavailable {
            background-color: darkgray;
        }

    .hover-layer {
        position: absolute;
        top: 15px;
        left: 25px;
        height: 30px;
        pointer-events: none;
        display: flex;
    }

    .time-block,
    .hover-cell {
        box-sizing: border-box;
    }
</style>

<MudDialog>
    <TitleContent>
        Измените расписание и подайте заявку на его изменение для данного дня. Красным отмечено забронированное время. Если вы измените его, заказ, связанный с этим временем будет отменён. Если вы хотите отредактировать запрос - пошлите новый. Он заменит старый.
    </TitleContent>
    <DialogContent>
        <MudStack Row="true">
            <MudDatePicker IsDateDisabledFunc="@((DateTime dt)=>(dt < DateTime.Today))" Style="max-width:600px;" Class="mb-8" @bind-Date="SelectedDate" Label="Выберите дату" PickerVariant="PickerVariant.Inline" />
            <MudButton Color="Color.Error" Style="max-width: fit-content;" @onclick="CancelChanges">Отменить изменения</MudButton>
        </MudStack>

        @if (AtuPattern != null && _selectedDate != null)
        {
            <div class="timeline-wrapper">
                <div class="hour-markers">
                    @for (int i = 0; i < AtuPattern.Length; i += 4)
                    {
                        <div class="hour-marker">@($"{i / 4}:00")</div>
                    }
                </div>

                <div class="availability-line"
                     @onmouseup="EndDrag"
                     @onmouseleave="EndDrag">
                    @for (int i = 0; i < AtuPattern.Length; i++)
                    {
                        int index = i;
                        <div class="time-block @(AtuPattern[index] ? "available" : "unavailable")"
                             style=@(occupiedIndexes.Contains(index) ? "background-color: crimson;" : "")
                             @onmousedown="e => StartDrag(e, index)"
                             @onmouseenter="() => ContinueDrag(index)">
                        </div>
                    }
                </div>
            </div>
        }

        <MudTextField Class="mt-8" @bind-Value="Message" Label="Причина изменения" Lines="4" FullWidth="true" />
    </DialogContent>
    <DialogActions>
        <MudText Style="color: crimson">@error</MudText>
        <MudButton Color="Color.Secondary" OnClick="Cancel">Отмена</MudButton>
        <MudButton Color="Color.Primary" OnClick="Submit">Подтвердить</MudButton>
    </DialogActions>
</MudDialog>

@code {
     /*
     * 1. Barber can alter schedule for 30 upcoming days.
     * 2. If barber makes unavailable a time block that's a part of some order, then, if schedule request is approved by the manager, the order is declined and the user is notified.
     * 3. Barber can send only one schedule adjustment request. If he sends another one for the same day - the schedule of the previous day will be altered.
     * 4. When booking, user sees the schedule of the schedule request for that day. The orders that are to decline in the request must all be marked unavailable - because we don't know
     * if request will be approved or not. If it won't be approved, we have a change of overlapping orders if we don't make times they booked unavailable. Later, when schedule request gets approved,
     * the times that are parts of declined orders will become available because we know the order was declined and won't be restored.
     */


    [CascadingParameter] private IMudDialogInstance MudDialog { get; set; }

    [Parameter] public Barber Barber { get; set; }
    [Parameter] public ClaimsPrincipal User { get; set; }

    private string Message { get; set; } = "";

    private DateTime? _selectedDate;
    private DateTime? SelectedDate
    {
        get => _selectedDate;
        set
        {
            if (_selectedDate != value)
            {
                _selectedDate = value;
                LoadAtuPattern();
            }
        }
    }

    private Dictionary<int, string> indexToColor = new();

    private List<int> occupiedIndexes = new();
    private List<Order> orders = new();
    private List<Order> ordersToDecline = new();
    private Dictionary<Tuple<int, int>, Order> idxRangeToOrder = new();

    private async Task LoadAtuPattern()
    {
        if (_selectedDate == null) return;

        var date = DateOnly.FromDateTime(_selectedDate.Value);

        var bsd = await Context.BarberScheduleDays
            .Where(x => x.Date == date && x.BarberId == Barber.Id)
            .FirstOrDefaultAsync();

        AtuPattern = bsd != null ? new BitArray(bsd.AtuPattern) : new BitArray(Barber.Bshop.DefaultSchedule);

        orders = await Context.Orders
            .Where(o =>
                DateOnly.FromDateTime(o.AppointedTime) == date &&
                o.BarberId == Barber.Id &&
                (o.Status == OrderStatus.Pending || o.Status == OrderStatus.Waiting))
            .Include(o => o.OrderJobs)
            .ToListAsync();

        occupiedIndexes.Clear();

        foreach (var order in orders)
        {
            int startIndex =
                order.AppointedTime.Hour * 4 +
                order.AppointedTime.Minute / 15;

            int totalDuration = order.OrderJobs.Sum(j => (int)j.Job.DurationAtu);

            idxRangeToOrder.Add(new Tuple<int, int>(startIndex, startIndex + totalDuration - 1), order);

            for (int i = 0; i < totalDuration; i++)
            {
                int idx = startIndex + i;
                if (idx >= 0 && idx < 96)
                    occupiedIndexes.Add(idx);
            }
        }

        StateHasChanged();
    }


    private void ToggleSlot(int index)
    {
        if (AtuPattern != null && index >= 0 && index < AtuPattern.Length)
            AtuPattern[index] = !AtuPattern[index];
    }

    private void Cancel() => MudDialog.Cancel();

    private ScheduleRequest? request;
    private string? error;
    private BitArray AtuPattern;

    private bool BitArraysEqual(BitArray a, BitArray b)
    {
        if (a == null || b == null) return false;
        if (a.Length != b.Length) return false;

        for (int i = 0; i < a.Length; i++)
            if (a[i] != b[i])
                return false;

        return true;
    }

    private async Task Submit()
    {
        if (string.IsNullOrWhiteSpace(Message))
        {
            error = "Укажите, пожалуйста, причину";
            return;
        }
        else if (_selectedDate == null)
        {
            error = "Выберите дату";
            return;
        }

        var bsd = await Context.BarberScheduleDays
            .Where(d => d.Date == DateOnly.FromDateTime(_selectedDate.Value) && d.BarberId == Barber.Id)
            .Select(d => d.AtuPattern)
            .FirstOrDefaultAsync();

        if ((bsd != null && BitArraysEqual(bsd, AtuPattern)) && ordersToDecline.Count == 0 || BitArraysEqual(AtuPattern, Barber.Bshop.DefaultSchedule))
        {
            error = "Вы не внесли никаких изменений";
            return;
        }

        var userId = int.Parse(User.Claims.First(c => c.Type == ClaimTypes.NameIdentifier).Value);
        var barberId = await Context.Barbers.Where(b => b.AccountId == userId).Select(b => b.Id).FirstOrDefaultAsync();
        var requestDate = DateOnly.FromDateTime(_selectedDate.Value);

        var alreadyExistingRequest = await Context.ScheduleRequests.Where(sr => sr.RequestDate == requestDate && sr.BarberId == barberId).FirstOrDefaultAsync();

        if (alreadyExistingRequest != null)
        {
            alreadyExistingRequest.AtuPattern = AtuPattern;
            alreadyExistingRequest.Message = Message;
            alreadyExistingRequest.Status = ScheduleRequestStatus.Pending;
            alreadyExistingRequest.OrderIdsToDecline = string.Join(" ", ordersToDecline.Select(o => o.Id.ToString()));
        }
        else
        {
            request = new ScheduleRequest
            {
                BarberId = barberId,
                RequestDate = requestDate,
                AtuPattern = AtuPattern,
                Message = Message,
                Status = ScheduleRequestStatus.Pending
            };

            request.OrderIdsToDecline = string.Join(" ", ordersToDecline.Select(o => o.Id.ToString()));

            Context.ScheduleRequests.Add(request);
        }


        await Context.SaveChangesAsync();

        await NotifyManager();

        Snackbar.Add("Запрос на изменение расписания подан", Severity.Info);
        MudDialog.Close(DialogResult.Ok(true));
    }

    private async Task NotifyManager()
    {
        var not = new Notification
            {
                Type = NotificationType.System,
                Content = $"Запрос на изменение расписания от {Barber.Account.Lastname} {Barber.Account.Restname} за {_selectedDate?.ToString("yyyy-MM-dd")}"
            };

        Context.Notifications.Add(not);
        await Context.SaveChangesAsync();

        var acc_not = new AccountNotification
            {
                AccountId = Barber.Bshop.ManagerAccountId,
                NotificationId = not.Id
            };

        Context.AccountNotifications.Add(acc_not);
        await Context.SaveChangesAsync();
    }

    private bool _isDragging = false;
    private bool _dragSetValue = true;


    private void StartDrag(MouseEventArgs e, int index)
    {
        if (e.Button != 0 || AtuPattern == null) return; // only left click

        if (occupiedIndexes.Contains(index))
        {
            foreach (var pair in idxRangeToOrder)
            {
                if (pair.Key.Item1 <= index && index <= pair.Key.Item2
                    && !ordersToDecline.Contains(idxRangeToOrder[pair.Key]))
                {
                    ordersToDecline.Add(idxRangeToOrder[pair.Key]);
                    occupiedIndexes.RemoveAll(x => pair.Key.Item1 <= x && x <= pair.Key.Item2);
                    for (int i = pair.Key.Item1; i <= pair.Key.Item2; i++)
                    {
                        AtuPattern[i] = true;
                    }
                    Console.WriteLine(pair.Key.Item1 + " " + pair.Key.Item2 + " order ID " + idxRangeToOrder[pair.Key].Id);
                }
            }

            occupiedIndexes.Remove(index);
        }

        _isDragging = true;

        // decide whether we are making blocks available or unavailable
        _dragSetValue = !AtuPattern[index];

        // apply the value to the clicked block
        AtuPattern[index] = _dragSetValue;

        StateHasChanged();
    }

    private void ContinueDrag(int index)
    {
        if (!_isDragging || AtuPattern == null || index < 0 || index >= AtuPattern.Length)
            return;

        AtuPattern[index] = _dragSetValue;
        StateHasChanged();
    }

    private void EndDrag()
    {
        _isDragging = false;
    }

    private async Task CancelChanges()
    {
        Console.WriteLine("CancelChanges invoked");

        var bsd = await Context.BarberScheduleDays
            .Where(x => x.Date == DateOnly.FromDateTime(SelectedDate.Value) && x.BarberId == Barber.Id)
            .FirstOrDefaultAsync();

        AtuPattern.SetAll(true);
        var sched = bsd != null ? bsd.AtuPattern : Barber.Bshop.DefaultSchedule;
        AtuPattern.And(sched);
        ordersToDecline.Clear();

        foreach (var order in orders)
        {
            int startIndex =
                order.AppointedTime.Hour * 4 +
                order.AppointedTime.Minute / 15;

            int totalDuration = order.OrderJobs.Sum(j => (int)j.Job.DurationAtu);

            for (int i = 0; i < totalDuration; i++)
            {
                int idx = startIndex + i;
                if (idx >= 0 && idx < 96)
                    occupiedIndexes.Add(idx);
            }
        }

        StateHasChanged();
    }
}