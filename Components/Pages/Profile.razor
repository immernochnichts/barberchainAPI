@namespace barberchainAPI.Components.Pages
@using MudBlazor
@using System.Collections
@using System.Security.Claims
@using barberchainAPI.Functional;
@using Microsoft.AspNetCore.Components.Authorization
@inject IDialogService DialogService
@inject BarberchainDbContext Context
@inject CartService CartService
@inject ISnackbar Snackbar
@inject IJSRuntime JS
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

@if (account is null)
{
    <MudText>
        Loading...
    </MudText>
}
else
{
    <MudPaper Elevation="3" Class="p-4 rounded-lg">

        <MudContainer Style="display:flex; padding-top:1rem; gap:1.5rem;">

        <!-- Profile picture -->
        <div style="position:relative;">
            <MudImage Src="@AccountPage.GetImageSrc(IsEditing ? EditableAccount.ProfilePic : account.ProfilePic)"
                      Class="rounded-lg"
                      Elevation="25"
                      ObjectFit="ObjectFit.Cover"
                      Style="max-width:350px; max-height:400px; margin-bottom:1rem;" />

            @if (IsEditing)
            {
                <InputFile OnChange="OnProfilePicChanged" accept="image/*" style="position:absolute; bottom:10px; left:10px; background:white;" />
            }
        </div>

        <!-- Account info -->
        <MudContainer Style="display:flex; flex-direction:column; align-items:flex-start;">

            @if (!IsEditing)
            {
                <MudText Typo="Typo.h5">@account.Lastname @account.Restname</MudText>
                <MudText Typo="Typo.h6">обо мне:</MudText>
                <MudText Typo="Typo.subtitle1" Class="text-secondary">@account.Bio</MudText>
                <MudText Typo="Typo.h6">день рождения: @account.BirthDate</MudText>
                @if (user != null && user.Identity.IsAuthenticated && account.Id == int.Parse(user.Claims.First(c => c.Type == ClaimTypes.NameIdentifier).Value))
                {
                    <MudText Typo="Typo.subtitle2" Align="Align.Start">электронная почта: @account.Email</MudText>
                    <MudText Typo="Typo.subtitle2" Align="Align.Start">номер телефона: @account.Phone</MudText>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Style="margin-bottom: 1rem;" Class="ml-auto mt-auto"
                                OnClick="StartEditing">
                        Редактировать
                    </MudButton>
                }
            }
            else
            {
                <MudTextField @bind-Value="EditableAccount.Lastname" Label="фамилия (или username)" />
                <MudTextField @bind-Value="EditableAccount.Restname" Label="имя отчество" />
                <MudTextField @bind-Value="EditableAccount.Bio" Label="о себе" Lines="3" />
                <MudDatePicker @bind-Date="BirthDateEdit" Label="день рождения" />
                <MudTextField @bind-Value="EditableAccount.Phone" Label="номер телефона" Lines="1" />

                <MudStack Direction="Row" Spacing="2" Class="mt-3 mb-3">

                    <MudButton Variant="Variant.Filled" Color="Color.Success"
                               OnClick="SaveEditing">
                        Сохранить
                    </MudButton>

                    <MudButton Variant="Variant.Outlined" Color="Color.Error"
                               OnClick="CancelEditing">
                        Отмена
                    </MudButton>

                </MudStack>
            }

            @if (account.Role == AccountRole.Barber)
            {
                <MudText Typo="Typo.h6" Align="Align.Center">что я умею:</MudText>
                <MudText Typo="Typo.body1" Align="Align.Center" Class="text-secondary">
                    @if (jobs is not null && cart != null)
                    {
                        <MudList T="string">
                            @foreach (var job in jobs)
                            {
                                <MudContainer Class="d-flex" Style="align-items:center">
                                    <MudListItem Text=@job.Job.Name SecondaryText=@(job.Price is null ? job.Job.DefaultPrice.ToString() : job.Price.ToString()) />
                                    <MudButton @onclick="async () => { await OnServiceClicked(job.Job); }" Disabled="false" Style=@($"background:{(cart.JobSet.Contains(job.Job) ? "gray" : job.Job.ColorCSS)}; height:min-content;")>@(cart.JobSet.Contains(job.Job) ? "Добавлено" : "")</MudButton>
                                </MudContainer>
                            }
                        </MudList>
                    }
                </MudText>
            }
        </MudContainer>

    </MudContainer>

        @if (account.Role == AccountRole.Barber)
        {
            <MudDivider Class="my-4" />

            <!-- Auxiliary Pictures Grid -->
            <MudText Typo="Typo.h6" Class="mb-2">Gallery</MudText>
            @if (barber?.Images != null && barber.Images.Any())
            {
                @foreach (var img in barber.Images)
                {
                    <MudGrid GutterSize="2">
                        <MudItem xs="6" sm="4" md="3">
                            <MudPaper Elevation="1" Class="p-1 rounded">
                                <MudImage Src="@AccountPage.GetImageSrc(img.ImgFile)" Alt="Auxiliary image" Style="width:100%;height:auto;" />
                            </MudPaper>
                        </MudItem>
                    </MudGrid>
                }
            }
            else
            {
                <MudText Align="Align.Left">No images available</MudText>
            }

            <MudDivider Class="my-4" />

            <!-- Calendar Section -->
            <MudText Typo="Typo.h6" Class="mb-2">Schedule</MudText>
            <MudDatePicker IsDateDisabledFunc="@((DateTime dt)=>(dt < DateTime.Today || dt > DateTime.Today.AddDays(7)))" PickerVariant="PickerVariant.Static" Orientation="Orientation.Landscape" @bind-Date="_selectedDate" />

            <MudDivider Class="my-4" />

            <MudButton @onclick="OpenDialogAsync" Variant="Variant.Filled" Color="Color.Primary">
                Забронировать
            </MudButton>


            <MudDivider Class="my-4" />

            <MudPaper Elevation="3" Class="p-6 rounded-lg">
                <MudStack Spacing="3">
                    <MudText Typo="Typo.h4">Отзывы</MudText>
                    <AuthorizeView>
                        <MudExpansionPanel Text="Оставить отзыв" @ref="reviewPanel">
                            <MudPaper Class="pa-4">
                                <MudForm @ref="_form" @bind-IsValid="isFormValid">
                                    <MudRating @bind-SelectedValue="reviewModel.Score" MaxValue="5" Size="Size.Large" Required="true" />

                                    <MudText Typo="Typo.subtitle2">Если вы хотите оставить отзыв по определенному заказу, пожалуйста, укажите его здесь</MudText>
                                    <MudSelect T="int" @bind-Value="reviewModel.OrderId">
                                        @if (userOrders != null)
                                        {
                                            @foreach (var o in userOrders)
                                            {
                                                <MudSelectItem T="int" Value="@o.Id">@($"Заказ #{o.Id} - {o.AppointedTime:dd.MM.yyyy}")</MudSelectItem>
                                            }
                                        }
                                    </MudSelect>

                                    <MudTextField T="string" Label="Ваш отзыв" @bind-Value="reviewModel.Text"
                                                  Lines="4" />

                                    <MudStack Class="mt-4" AlignItems="AlignItems.End" Row="true">
                                        <MudButton Style="color: gray;" Variant="Variant.Filled" OnClick="CancelReview">
                                            Отмена
                                        </MudButton>
                                        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="SubmitReview">
                                            Отправить
                                        </MudButton>
                                    </MudStack>
                                </MudForm>
                            </MudPaper>
                        </MudExpansionPanel>
                    </AuthorizeView>

                    <MudDivider Class="mb-2" />

                    <ReviewsForBarber user="@user" barber="@barber" @ref="reviewsForBarber"></ReviewsForBarber>
                </MudStack>
            </MudPaper>
        }
    </MudPaper>
}

@code{
    [Parameter]
    public int id { get; set; }

    [Parameter]
    public Account? account { get; set; }

    [Parameter]
    public ClaimsPrincipal? user { get; set; }

    private Cart? cart;

    private bool _loaded = false;

    private bool IsEditing = false;

    private Account EditableAccount = new(); // copy of account data for editing

    private DateTime? BirthDateEdit
    {
        get => EditableAccount.BirthDate?.ToDateTime(TimeOnly.MinValue);
        set => EditableAccount.BirthDate = DateOnly.FromDateTime(value.Value);
    }


    void StartEditing()
    {
        EditableAccount = new Account
        {
            Id = account.Id,
            Lastname = account.Lastname,
            Restname = account.Restname,
            Bio = account.Bio,
            BirthDate = account.BirthDate,
            ProfilePic = account.ProfilePic
        };

        IsEditing = true;
    }

    void CancelEditing()
    {
        IsEditing = false;
    }

    async Task SaveEditing()
    {
        account.Lastname = EditableAccount.Lastname;
        account.Restname = EditableAccount.Restname;
        account.Bio = EditableAccount.Bio;
        account.BirthDate = EditableAccount.BirthDate;
        account.ProfilePic = EditableAccount.ProfilePic;
        account.Phone = EditableAccount.Phone;

        Context.Accounts.Update(account);
        await Context.SaveChangesAsync();

        Snackbar.Add("Изменения сохранены", Severity.Success);
        IsEditing = false;
        StateHasChanged();
    }

    private async Task OnProfilePicChanged(InputFileChangeEventArgs e)
    {
        var file = e.File;
        using var ms = new MemoryStream();
        await file.OpenReadStream(1024 * 1024 * 3).CopyToAsync(ms);

        EditableAccount.ProfilePic = ms.ToArray();
    }

    //Barber variables
    [Parameter]
    public List<BarberJob> jobs { get; set; }

    [Parameter]
    public Barber? barber { get; set; }

    public BitArray? AtuPattern { get; set; }

    protected DateTime? _selectedDate = DateTime.Today;

    public async Task<BitArray> GetAvailabilityForDay(int barberId, DateTime? day)
    {
        var schedRequest = await Context.ScheduleRequests   // first check schedule requests
            .Where(a => a.BarberId == barberId && a.RequestDate == DateOnly.FromDateTime(day.Value) && a.Status == ScheduleRequestStatus.Pending)
            .FirstOrDefaultAsync();

        var availability = schedRequest?.AtuPattern;

        if (availability != null)
        {
            foreach (var strId in schedRequest.OrderIdsToDecline.Split(" ", StringSplitOptions.RemoveEmptyEntries))
            {
                Console.WriteLine("Current order ID: " + strId);

                int orderId = int.Parse(strId);

                Console.WriteLine("Current order ID after parsing: " + strId);

                var order = await Context.Orders.Include(o => o.OrderJobs).Where(o => o.Id == orderId).FirstOrDefaultAsync();
                var declinedOrderJobs = order.OrderJobs.Select(oj => oj.Job);
                var orderDuration = declinedOrderJobs.Select(oj => (int)oj.DurationAtu).Sum();

                int startIdx = order.AppointedTime.Hour * 4 + order.AppointedTime.Minute / 15;
                int endIdx = startIdx + orderDuration - 1;

                for (int i = startIdx; i <= endIdx; i++)
                {
                    availability[i] = false;    // mark times booked by potentially declined orders as unavailable to avoid overlapping
                }
            }

            return availability;
        }
        else
        {
            availability = await Context.BarberScheduleDays // then check schedule days
                .Where(a => a.BarberId == barberId && a.Date == DateOnly.FromDateTime(day.Value))
                .Select(a => a.AtuPattern)
                .FirstOrDefaultAsync();

            return availability ?? new BitArray(Enumerable.Repeat<bool>(false, 96).ToArray());
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstTime)
    {
        if (firstTime)
        {
            cart = await CartService.GetCart();
            StateHasChanged();
        }
    }

    protected async Task OpenDialogAsync()
    {
        AtuPattern = await GetAvailabilityForDay(barber.Id, _selectedDate);

        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.ExtraExtraLarge, FullWidth = true };
        var params_ = new DialogParameters<BarberPageDialog> {
            { x => x.AtuPattern, AtuPattern }, 
            { y => y.SelectedDate, _selectedDate}, 
            { z => z.Barber, barber },
            { w => w.user, user } };

        await DialogService.ShowAsync<BarberPageDialog>("Book time", params_, options);
    }

    private async Task OnServiceClicked(Job j)
    {
        if (cart.JobSet.Contains(j))
        {
            await CartService.RemoveItem(j.Id);
        }
        else
        {
            await CartService.AddToCart(j);
        }

        cart = await CartService.GetCart(); // update the cart

        StateHasChanged();
    }

    private MudForm _form;
    private MudExpansionPanel reviewPanel;
    private bool isFormValid;

    private ReviewModel reviewModel = new ReviewModel();

    private List<Order> userOrders = new List<Order>();

    private ReviewsForBarber reviewsForBarber;

    protected override async Task OnInitializedAsync()
    {
        if (user is null || !user.Claims.Any())
        {
            userOrders = null;
            return;
        }

        var userId = int.Parse(user.Claims.First(c => c.Type == ClaimTypes.NameIdentifier).Value);

        if (barber != null)
        {
            userOrders = await Context.Orders
                .Where(o => o.AccountId == userId && o.BarberId == barber.Id && o.Status == OrderStatus.Complete)
                .ToListAsync();
        }
    }

    private async Task SubmitReview()
    {
        await _form.Validate();
        if (!isFormValid)
            return;

        var userId = int.Parse(user.Claims.First(c => c.Type == ClaimTypes.NameIdentifier).Value);

        if (!await Context.Orders.AnyAsync(o => o.BarberId == barber.Id && o.AccountId == userId && o.Status == OrderStatus.Complete))
        {
            Snackbar.Add("Вы не можете оставить отзыв о сотруднике, если у вас нет с ним ни единого выполненного заказа", Severity.Info);
            return;
        }

        if (await Context.Reviews.AnyAsync(r => r.BarberId == barber.Id && r.AccountId == userId))
        {
            barber.ReviewSum += reviewModel.Score;
            barber.ReviewCount += 1;

            var review = new Review
                {
                    Score = (short)reviewModel.Score,
                    Text = reviewModel.Text,
                    OrderId = reviewModel.OrderId == 0 ? null : reviewModel.OrderId,
                    AccountId = userId,
                    BarberId = barber.Id,
                    CreatedAt = DateTime.Now
                };

            // adding review to the db
            Context.Reviews.Add(review);
            await Context.SaveChangesAsync();

            // sending notification to the barber
            var not = new Notification
            {
                Type = NotificationType.General,
                Content = "Пользователь оставил новый отзыв о Вас:\n\n" + review.Text
            };

            Context.Notifications.Add(not);
            await Context.SaveChangesAsync();

            var acc_not = new AccountNotification
            {
                AccountId = barber.AccountId.Value,
                NotificationId = not.Id
            };

            Context.AccountNotifications.Add(acc_not);
            await Context.SaveChangesAsync();

            reviewModel = new ReviewModel();
            await _form.ResetAsync();
            await reviewsForBarber.Refresh();
            Snackbar.Add("Отзыв успешно отправлен", Severity.Success);

        }
        else
        {
            Snackbar.Add("Вы уже оставили отзыв об этом сотруднике", Severity.Info);
        }
    }

    private async Task CancelReview()
    {
        await _form?.ResetAsync(); 
        reviewPanel?.CollapseAsync();
    }

    public class ReviewModel
    {
        public int Score { get; set; }
        public int OrderId { get; set; }
        public string Text { get; set; }
    }
}